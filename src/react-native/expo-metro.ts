import * as fs from 'node:fs';
// @ts-expect-error - clack is ESM and TS complains about that. It works though
import * as clack from '@clack/prompts';
// @ts-expect-error - magicast is ESM and TS complains about that. It works though
import type { ProxifiedModule } from 'magicast';
import chalk from 'chalk';
import * as Sentry from '@sentry/node';

import { getLastRequireIndex, hasSentryContent } from '../utils/ast-utils';
import { makeCodeSnippet, showCopyPasteInstructions } from '../utils/clack';

import {
  findMetroConfigPath,
  parseMetroConfig,
  writeMetroConfig,
} from './metro';

import * as recast from 'recast';
import x = recast.types;
import t = x.namedTypes;

const b = recast.types.builders;

export async function addSentryToExpoMetroConfig() {
  let metroConfigPath = findMetroConfigPath();

  if (!metroConfigPath) {
    // No existing metro config found, create metro.config.js (Expo default)
    metroConfigPath = 'metro.config.js';
  }

  if (!fs.existsSync(metroConfigPath)) {
    const success = await createSentryExpoMetroConfig(metroConfigPath);
    if (!success) {
      Sentry.setTag('expo-metro-config', 'create-new-error');
      return await showInstructions(metroConfigPath);
    }
    Sentry.setTag('expo-metro-config', 'created-new');
    return undefined;
  }

  Sentry.setTag('expo-metro-config', 'exists');
  clack.log.info(`Updating existing ${metroConfigPath}.`);

  const mod = await parseMetroConfig(metroConfigPath);
  if (!mod) {
    return await showInstructions(metroConfigPath);
  }

  let didPatch = false;
  try {
    didPatch = patchMetroInMemory(mod, metroConfigPath);
  } catch (e) {
    Sentry.captureException('Unable to patch expo metro config');
  }
  if (!didPatch) {
    Sentry.setTag('expo-metro-config', 'patch-error');
    clack.log.error(
      `Could not patch ${chalk.cyan(
        metroConfigPath,
      )} with Sentry configuration.`,
    );
    return await showInstructions(metroConfigPath);
  }

  const saved = await writeMetroConfig(mod, metroConfigPath);
  if (saved) {
    Sentry.setTag('expo-metro-config', 'patch-saved');
    clack.log.success(
      chalk.green(`${chalk.cyan(metroConfigPath)} changes saved.`),
    );
  } else {
    Sentry.setTag('expo-metro-config', 'patch-save-error');
    clack.log.error(
      `Could not save changes to ${chalk.cyan(
        metroConfigPath,
      )}, please follow the manual steps.`,
    );
    return await showInstructions(metroConfigPath);
  }
}

export function patchMetroInMemory(
  mod: ProxifiedModule,
  metroConfigPath: string,
): boolean {
  const ast = mod.$ast as t.Program;

  if (hasSentryContent(ast)) {
    clack.log.warn(
      `The ${chalk.cyan(
        metroConfigPath,
      )} file already has Sentry configuration.`,
    );
    return false;
  }

  let didReplaceDefaultConfigCall = false;

  recast.visit(ast, {
    visitVariableDeclaration(path) {
      const { node } = path;

      if (
        // path is require("expo/metro-config")
        // and only getDefaultConfig is being destructured
        // then remove the entire declaration
        node.declarations.length > 0 &&
        node.declarations[0].type === 'VariableDeclarator' &&
        node.declarations[0].init &&
        node.declarations[0].init.type === 'CallExpression' &&
        node.declarations[0].init.callee &&
        node.declarations[0].init.callee.type === 'Identifier' &&
        node.declarations[0].init.callee.name === 'require' &&
        node.declarations[0].init.arguments[0].type === 'StringLiteral' &&
        node.declarations[0].init.arguments[0].value === 'expo/metro-config' &&
        node.declarations[0].id.type === 'ObjectPattern' &&
        node.declarations[0].id.properties.length === 1 &&
        node.declarations[0].id.properties[0].type === 'ObjectProperty' &&
        node.declarations[0].id.properties[0].key.type === 'Identifier' &&
        node.declarations[0].id.properties[0].key.name === 'getDefaultConfig'
      ) {
        path.prune();
        return false;
      }

      this.traverse(path);
    },

    visitCallExpression(path) {
      const { node } = path;
      if (
        // path is getDefaultConfig
        // then rename it to getSentryExpoConfig
        node.callee.type === 'Identifier' &&
        node.callee.name === 'getDefaultConfig'
      ) {
        node.callee.name = 'getSentryExpoConfig';
        didReplaceDefaultConfigCall = true;
        return false;
      }

      this.traverse(path);
    },
  });

  if (!didReplaceDefaultConfigCall) {
    clack.log.warn(
      `Could not find \`getDefaultConfig\` in ${chalk.cyan(metroConfigPath)}.`,
    );
    return false;
  }

  addSentryExpoConfigRequire(ast, metroConfigPath);

  return true;
}

export function addSentryExpoConfigRequire(
  program: t.Program,
  metroConfigPath: string,
) {
  try {
    const lastRequireIndex = getLastRequireIndex(program);
    const sentryExpoConfigRequire = createSentryExpoConfigRequire();

    // Add the require statement after the last require or at the beginning
    program.body.splice(lastRequireIndex + 1, 0, sentryExpoConfigRequire);
  } catch (error) {
    clack.log.error(
      `Could not add Sentry Expo config require statement to ${chalk.cyan(
        metroConfigPath,
      )}.`,
    );
    Sentry.captureException(
      `Could not add Sentry Expo config require statement to ${metroConfigPath}.`,
    );
  }
}

/**
 * Creates const { getSentryExpoConfig } = require("@sentry/react-native/metro");
 */
function createSentryExpoConfigRequire() {
  return b.variableDeclaration('const', [
    b.variableDeclarator(
      b.objectPattern([
        b.objectProperty.from({
          key: b.identifier('getSentryExpoConfig'),
          value: b.identifier('getSentryExpoConfig'),
          shorthand: true,
        }),
      ]),
      b.callExpression(b.identifier('require'), [
        b.literal('@sentry/react-native/metro'),
      ]),
    ),
  ]);
}

async function createSentryExpoMetroConfig(
  metroConfigPath: string,
): Promise<boolean> {
  const snippet = `const { getSentryExpoConfig } = require("@sentry/react-native/metro");

const config = getSentryExpoConfig(__dirname);

module.exports = config;
`;
  try {
    await fs.promises.writeFile(metroConfigPath, snippet);
  } catch (e) {
    clack.log.error(
      `Could not create ${chalk.cyan(
        metroConfigPath,
      )} with Sentry configuration.`,
    );
    Sentry.captureException(
      `Could not create ${metroConfigPath} with Sentry configuration.`,
    );
    return false;
  }
  clack.log.success(
    `Created ${chalk.cyan(metroConfigPath)} with Sentry configuration.`,
  );
  return true;
}

function showInstructions(metroConfigPath: string) {
  return showCopyPasteInstructions({
    filename: metroConfigPath,
    codeSnippet: getMetroWithSentryExpoConfigSnippet(true),
  });
}

function getMetroWithSentryExpoConfigSnippet(colors: boolean): string {
  return makeCodeSnippet(colors, (unchanged, plus, minus) =>
    unchanged(`${minus(
      `// const { getDefaultConfig } = require("expo/metro-config");`,
    )}
${plus(
  `const { getSentryExpoConfig } = require("@sentry/react-native/metro");`,
)}

${minus(`// const config = getDefaultConfig(__dirname);`)}
${plus(`const config = getSentryExpoConfig(__dirname);`)}

module.exports = config;`),
  );
}
